import socket
import struct
import threading
import time
import cv2
import numpy as np
from queue import Queue


class TCPVideoReceiver(threading.Thread):
    def __init__(self, host="0.0.0.0", port=5015, queue_size=2):
        super().__init__(daemon=True)
        self.host = host
        self.port = port
        self.frames = Queue(maxsize=queue_size)
        self.running = True

    def _recv_all(self, sock, size):
        data = b''
        while len(data) < size:
            packet = sock.recv(size - len(data))
            if not packet:
                return None
            data += packet
        return data

    def run(self):
        while self.running:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
                    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    server.bind((self.host, self.port))
                    server.listen(1)

                    print(f"[VIDEO] Listening on {self.port}")
                    client, addr = server.accept()
                    print(f"[VIDEO] Connected: {addr}")

                    with client:
                        while self.running:
                            # --- читаем размер кадра ---
                            header = self._recv_all(client, 4)
                            if header is None:
                                print("[VIDEO] Connection closed")
                                break

                            frame_size = struct.unpack('!I', header)[0]

                            # --- читаем JPEG ---
                            frame_data = self._recv_all(client, frame_size)
                            if frame_data is None:
                                print("[VIDEO] Frame receive failed")
                                break

                            frame = cv2.imdecode(
                                np.frombuffer(frame_data, np.uint8),
                                cv2.IMREAD_COLOR
                            )

                            if frame is not None:
                                if self.frames.full():
                                    self.frames.get()  # выбрасываем старый кадр
                                self.frames.put(frame)

            except Exception as e:
                print(f"[VIDEO] Error: {e}, retrying...")
                time.sleep(0.01)

    def get_frame(self):
        if not self.frames.empty():
            return self.frames.get()
        return None

    def stop(self):
        self.running = False




class TCPVideoSender(threading.Thread):
    def __init__(self, ip, port, imag, jpeg_quality=80):
        super().__init__(daemon=True)
        self.ip = ip
        self.port = port
        self.imag = imag
        self.jpeg_quality = jpeg_quality
        self.running = True
        self.sock = None

    def run(self):
        while self.running:
            try:
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.sock.connect((self.ip, self.port))
                print(f"[SENDER] Connected to {self.ip}:{self.port}")

                while self.running:
                    frame = self.imag.get()
                    if frame is None:
                        time.sleep(0.01)
                        continue

                    ok, encoded = cv2.imencode(
                        ".jpg",
                        frame,
                        [int(cv2.IMWRITE_JPEG_QUALITY), self.jpeg_quality]
                    )
                    if not ok:
                        continue

                    data = encoded.tobytes()
                    size = len(data)

                    self.sock.sendall(struct.pack("!I", size))
                    self.sock.sendall(data)

            except Exception as e:
                print(f"[SENDER] Error: {e}, retrying...")
                time.sleep(0.01)

    def stop(self):
        self.running = False
        if self.sock:
            self.sock.close()
        print("[SENDER] Stopped")


